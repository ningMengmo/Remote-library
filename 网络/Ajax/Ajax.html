<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /*  
            XHR API
                构造函数的名称为XMLHttpRequest，简称为XHR，所以这套API又称之为XHR API

            Fetch API
                由于XHR API有着诸多缺陷，在HTML5和ES6发布之后，产生了一套更完善的API来发送请求。
                这套API主要使用的是一个叫做fetch的函数，因此这套API又称之为Fetch API

            无论是XHR还是Fetch，它们都是实现ajax的技术手段，只是API不同。
        
            网络是异步的

        */

        // XHR API
        var xhr = new XMLHttpRequest(); //创建发送请求的对象
        xhr.onreadystatechange = function () {  //当请求状态发生改变时运行的函数  接收参数
            // xhr.readyState： 一个数字，用于判断请求到了哪个阶段  按照下面的数字判断
            // 0: 刚刚创建好了请求对象，但还未配置请求（未调用open方法）
            // 1: open方法已被调用
            // 2: send方法已被调用
            // 3: 正在接收服务器的响应消息体
            // 4: 服务器响应的所有内容均已接收完毕
            // console.log(xhr.readyState);

            // xhr.responseText： 获取服务器响应的消息体文本

            // xhr.getResponseHeader("Content-Type") 获取响应头Content-Type
        }
        xhr.open("请求方法", "url地址"); //配置请求
        xhr.setRequestHeader("Content-Type", "application/json"); //设置请求头
        xhr.send("请求体内容"); //构建请求体，发送到服务器，如果没有请求体，传递null


        
        // Fetch API  返回一个 promise 对象
        const resp = await fetch('url地址', { // 请求配置对象，可省略，省略则所有配置为默认值
            method: '请求方法', // 默认为GET
            headers: { // 请求头配置
                'Content-Type': 'application/json',
                'a': 'abc'
            },
            body: '请求体内容' // 请求体
        }); // fetch会返回一个Promise，该Promise会在接收完响应头后变为fulfilled

        resp.headers; // 获取响应头对象
        resp.status; // 获取响应状态码，例如200
        resp.statusText; // 获取响应状态码文本，例如OK
        resp.json(); // 用json的格式解析即将到来的响应体，返回Promise，解析完成后得到一个对象
        resp.text(); // 用纯文本的格式解析即将到来的响应体，返回Promise，解析完成后得到一个字符串



    </script>
</body>

</html>